function [] = SampleGenerator()
    paraspath = "paras.mat";
    
    % Set parameters
    basic_paras(paraspath);
    sample_paras(paraspath);

    % Generate label/ground truth
    generate_label(paraspath);  % paras.BitDepth

    % Generate samples
    generate_molecular_set(paraspath);  % double
    generate_sample(paraspath); % paras.BitDepth
end

%% Help function for setting parameters 

function [] = basic_paras(paraspath)
    paras = [];

    % dimensional parameters that need to consider memory size
    paras.NumMolecule = 256;                % number of Gaussian we create to simulate molecule
    paras.NumFrame    = 5;                  % number of frames we have
    paras.DimFrame    = [128, 128, 64];    % dimensions of each frame, row-column-(depth); yx(z)
    paras.UpSampling  = [8, 8, 4];
    paras.BitDepth    = 'uint8';  
    
    % parameter that adjust distribution of sample parameters
    paras.PixelSize   = [65, 65, 100];  % we will use this to correct the covariance
    paras.MaxStd      = 2;              % parameter to adjust the size of covariance of Gaussian
    paras.LumRange    = [64, 255];
    paras.AppearRange = [1/8, 1/2];     % min/max % of moleculars appear in each frame

    save(paraspath, "paras")
end

function [] = sample_paras(paraspath)
    % Descriptions:
    % - This function will use basic parameters to randomly generate 
    %   sample parameters that used to generate sample. 
    % - Basic parameters can help us generate sample with same 
    %   distribution but not exatly same. To save a dataset, sample 
    %   parameters generated by this function need to be saved.
    % Rules:
    % - Every parameters will save in .mat file in 'paraspath.' We load 
    %   all basic parameters needed at begining and save all the sample
    %   parameters at the end of function. We won't access or modity the
    %   .mat file during function.
    % - When generting parameters, we use double and do not round the
    %   data. We will do all the dtype change or round the float at the 
    %   end of function, when saving parameter. 
    % Output:
    %   (D stands for number of dimensions, i.e., length(DimFrame))
    % - mu_set    [D * NumMolecule]           double  non-rounded
    % - cov_set   [D * D * NumMolecule]       double  non-rounded
    % - lum_set   [NumMolecule]               double  non-rounded
    % - mask_set  [NumFrame * NumMolecule]    logical

    % load the basic parameters we will use
    load(paraspath, "paras");
    NumMolecule = paras.NumMolecule;
    PixelSize   = paras.PixelSize;
    MaxStd      = paras.MaxStd;
    LumRange    = paras.LumRange;
    DimFrame    = paras.DimFrame;
    NumFrame    = paras.NumFrame; 
    AppearRange = paras.AppearRange;

    D = length(DimFrame);  % number of dimensions

    % 1. mu set, [D * NumMolecule]
    mu_set = (DimFrame-1)' .* rand([D, NumMolecule]) + 1;

    % 2. covariance set, [D * D * NumMolecule]
    cov_set = zeros(D, D, NumMolecule);
    % pixel size correction
    MaxStd = MaxStd * (PixelSize(1) ./ PixelSize);
    for n = 1:NumMolecule
        cov_set(:, :, n) = diag((MaxStd.^2) .* rand([1, D]));
    end
    
    % 3. luminance set, [NumMolecule]
    lum_set = (LumRange(2) - LumRange(1)) * rand([1, NumMolecule]);
    lum_set = lum_set + LumRange(1);
    
    % 4. mask set, [NumFrame, NumMolecule]
    % determine how many moleculars will appear in each frame
    NumRange = round(NumMolecule * AppearRange);
    num_appear_set = randi(NumRange, [NumFrame, 1]);
    % create a mask stands which moleculars will appear in each frame
    mask_set = zeros(NumFrame, NumMolecule);
    for n = 1:NumFrame
        index = randperm(NumMolecule, num_appear_set(n));
        mask_set(n, index) = 1;  % mask of a molecular is 1 if appear
    end

    % save sample parameters in 'paras,' change dtype/rounded meantime
    paras.mu_set    = mu_set;
    paras.cov_set   = cov_set;
    paras.lum_set   = lum_set;
    paras.mask_set  = logical(mask_set);
    save(paraspath, "paras")
end

%% Help function for generating label/ground truth

function [] = generate_label(paraspath)
    % load basic and sample parameters we will use
    load(paraspath, "paras");
    NumMolecule = paras.NumMolecule;
    NumFrame    = paras.NumFrame; 
    DimFrame    = paras.DimFrame;
    UpSampling  = paras.UpSampling;
    BitDepth    = paras.BitDepth;
    mu_set      = paras.mu_set;
    lum_set     = paras.lum_set;
    mask_set    = paras.mask_set;
    
    DimFrame_up = UpSampling .* DimFrame;
    mu_set_up   = UpSampling' .* mu_set;
    
    if ~exist("label", 'dir')
        mkdir("label");
    end

    for f = 1:NumFrame
        label = zeros(DimFrame_up, BitDepth);
        for m = 1:NumMolecule
            mu_up = round(mu_set_up(:, m));
            index = arrayfun(@(x) x, mu_up, 'UniformOutput', false);
            label(index{:}) = lum_set(m) * mask_set(f, m);
        end
        
        % save as .mat and .tif
        path = fullfile("label", f + "_label");
        save_frame(path, label, true, true);
    end
end

%% Help function for generating samples

function molecular = generate_molecular(paraspath, m)
    % load basic and sample parameters we will use
    load(paraspath, "paras");
    DimFrame    = paras.DimFrame;
    mu          = paras.mu_set(:, m);
    cov         = paras.cov_set(:, :, m);
    lum         = paras.lum_set(m);

    D = length(DimFrame);  % number of dimensions

    % take a slice around the mu where the radia is 4 * std
    radius      = ceil(4 * sqrt(diag(cov)));
    lower       = floor(max(mu - radius, ones(D, 1)));
    upper       = ceil(min(mu + radius, DimFrame'));
    diameter    = upper - lower + 1; 
    
    % build coordinate system of the slice
    %{ 
    We use 'ndgrid' instead of 'meshgrid' to match the coordinate system of
    the mu/lower/upper above.
    For example, if diameter is [11 13 8], meshgrid will return three 
    [13 11 8] matrix but ndgrid return three [11 13 8] matrix.
    'meshgrid' use Cartesian coordinate system, i.e. 11 is range of 
    x-axis/column, 13 is range of y-axis/row.
    'ndgrid' use matrix coordinate system, i.e. 11 is range of y-axis/row 
    and 13 is range of x-axis/column. 
    Above, for mu/lower/upper, we use matrix coordinate system, thus here
    we use 'ndgrid'
    %}
    index = arrayfun(@(low, up) low:up, lower, upper, 'UniformOutput', false);
    grid_cell = cell(1, D);
    [grid_cell{:}] = ndgrid(index{:}); 
    coord = cat(D+1, grid_cell{:});                 % [y, x, (z), D]
    coord = reshape(coord, [], D);                  % [yx(z), D]

    % compute the probability density for each point/pixel in slice
    pdf_values = mvnpdf(coord, mu', cov);           % [yx(z), D]
    
    % set the luminate 
    pdf_values = pdf_values * lum / max(pdf_values(:));

    % put the slice back to whole frame to get single molecular frame
    molecular = zeros(DimFrame);
    for i = 1:prod(diameter)
        idx = cellfun(@(x) x(i), grid_cell, 'UniformOutput', false);
        molecular(idx{:}) = pdf_values(i);
    end
end

function [] = generate_molecular_set(paraspath)
    % load basic and sample parameters we will use
    load(paraspath, "paras");
    NumMolecule = paras.NumMolecule;
    
    if ~exist("molecular", 'dir')
        mkdir("molecular");
    end

    for m = 1:NumMolecule
        molecular = generate_molecular(paraspath, m);

        % save as .mat and .tif
        path = fullfile("molecular", m + "_molecular");
        save_frame(path, molecular, true, true);
    end
end

function [] = generate_sample(paraspath)
    % load basic and sample parameters we will use
    load(paraspath, "paras");
    NumMolecule = paras.NumMolecule;
    NumFrame    = paras.NumFrame;
    DimFrame    = paras.DimFrame;
    BitDepth    = paras.BitDepth;
    mask_set    = paras.mask_set;
    
    if ~exist("sample", 'dir')
        mkdir("sample");
    end
    
    % load the molecular frame set in .mat format
    m_frame_set = zeros([NumMolecule, DimFrame]);
    for m = 1:NumMolecule
        path = fullfile("molecular", m + "_molecular.mat");
        load(path, "frame");
        m_frame_set(m, :) = frame(:);
    end

    % Perform the einsum operations
    for f = 1:NumFrame
        sample = reshape(mask_set(f, :) * m_frame_set(:, :), DimFrame);
        sample = feval(BitDepth, sample);

        % save as .mat and .tif
        path = fullfile("sample", f + "_sample");
        save_frame(path, sample, true, true);
    end
end

%% Help function for save frame into .tif file

function [] = save_frame(path, frame, mat, tif)
    % .mat will always use the dtype of orginal variable without
    % modification. .tif is for illustration so we will force to round it
    % and convert to uint8. 

    % .mat 
    if mat == true
        save(path+".mat", "frame");
    end
    
    % .tif
    if tif == true
        frame = uint8(round(frame));
        DimFrame = size(frame);
        if length(DimFrame) == 2
            imwrite(frame, path+".tif", 'WriteMode', 'overwrite',  'Compression','none');
        end
        if length(DimFrame) == 3
            imwrite(frame(:, :, 1), path+".tif", 'WriteMode', 'overwrite',  'Compression','none');
            for d = 2:DimFrame(3)
                imwrite(frame(:, :, d), path+".tif", 'WriteMode', 'append',  'Compression','none');
            end
        end
    end
end
