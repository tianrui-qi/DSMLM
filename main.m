function trainedNet = main()
    % set parameters
    paras = [];
    paras = setBasicParas(paras);
    paras = generateSampleParas(paras);
    
    % set dataloader
    dataloader = Dataloader(paras);

    % set network
    unet = uNet();

    options = trainingOptions('adam', ...
    'InitialLearnRate', 0.01, ...
    'MaxEpochs', 20, ...
    'MiniBatchSize', paras.NumFrame, ...
    'Shuffle', 'never', ...
    'Plots', 'training-progress');

    trainedNet = trainNetwork(dataloader, unet, options);
end

%% Set parameters

function paras = setBasicParas(paras)
    % dimensional parameters that need to consider memory
    paras.NumMolecule = 64;             % big affect on running time
    paras.NumFrame    = 1;
    paras.DimFrame    = [128, 128, 64]; % row-column-(depth); yx(z)
    paras.UpSampling  = [8, 8, 8];

    % parameters that adjust distribution of sample parameters
    paras.PixelSize   = [65, 65, 100];  % use to correct the covariance
    paras.MaxStd      = 2;              % adjust covariance of moleculars
    paras.LumRange    = [1/512, 1];
    paras.AppearRange = [1/8, 1/1];     % min, max % of moleculars/frame

    % parameters for adding noise
    paras.noise_mu  = 0;
    paras.noise_var = 1/512;
end

function paras = generateSampleParas(paras)
    % Descriptions:
    % - This function will use basic parameters to randomly generate
    %   sample parameters that used to generate sample.
    % - Basic parameters can help us generate sample with same
    %   distribution but not exatly same. To save a dataset, sample
    %   parameters generated by this function need to be saved so that we
    %   do not need to save the save to save memeory and avoid I/O
    %   performance.
    % Rules:
    % - We load all basic parameters needed at begining and save all the
    %   sample parameters at the end of function. We won't access or modity
    %   the paras during function.
    % - When generting parameters, we use double and do not round the
    %   data. We will do all the dtype change or round the float at the
    %   end of function, when saving parameter.
    % Output:
    %   (D stands for number of dimensions, i.e., length(DimFrame))
    % - mu_set    [D * NumMolecule]           double  non-rounded
    % - cov_set   [D * D * NumMolecule]       double  non-rounded
    % - lum_set   [NumMolecule]               double  non-rounded
    % - mask_set  [NumFrame * NumMolecule]    logical

    % load the basic parameters we will use
    NumMolecule = paras.NumMolecule;
    NumFrame    = paras.NumFrame;
    DimFrame    = paras.DimFrame;
    PixelSize   = paras.PixelSize;
    MaxStd      = paras.MaxStd;
    LumRange    = paras.LumRange;
    AppearRange = paras.AppearRange;

    D = length(DimFrame);  % number of dimensions

    % 1. mu set, [D * NumMolecule]
    mu_set = (DimFrame-1)' .* rand([D, NumMolecule]) + 1;

    % 2. covariance set, [D * D * NumMolecule]
    cov_set = zeros(D, D, NumMolecule);
    % pixel size correction
    MaxStd = MaxStd * (PixelSize(1) ./ PixelSize);
    for n = 1:NumMolecule
        cov_set(:, :, n) = diag((MaxStd.^2) .* rand([1, D]));
    end

    % 3. luminance set, [NumMolecule]
    lum_set = (LumRange(2) - LumRange(1)) * rand([1, NumMolecule]);
    lum_set = lum_set + LumRange(1);

    % 4. mask set, [NumFrame, NumMolecule]
    % determine how many moleculars will appear in each frame
    NumRange = round(NumMolecule * AppearRange);
    num_appear_set = randi(NumRange, [NumFrame, 1]);
    % create a mask stands which moleculars will appear in each frame
    mask_set = zeros(NumFrame, NumMolecule);
    for n = 1:NumFrame
        index = randperm(NumMolecule, num_appear_set(n));
        mask_set(n, index) = 1;  % mask of a molecular is 1 if appear
    end

    % save sample parameters in 'paras,' change dtype/rounded meantime
    paras.mu_set    = mu_set;
    paras.cov_set   = cov_set;
    paras.lum_set   = lum_set;
    paras.mask_set  = logical(mask_set);
end
