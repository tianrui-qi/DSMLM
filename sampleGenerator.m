% This file is not used to generate sample when training:
% - We add SaveTif component in the main function for illustration purpose, 
%   which increase the running time due to I/O performance. This comoponent 
%   will be deleted in the file we use to generate sample when training,
%   including two help functions for saving .tif and save statement in
%   main function. 
% - The pipeline design is not efficient in this file. For the pipeline we
%   use in function 'SampleGenerator' (main function), we first generate
%   molecular and then generate label and sample. However, generate
%   molecular will cost most of time where in training process we need to
%   generate new sample and label in each branch. Creat a molecular set
%   every time we generate sample and label is not efficient. Thus, in the
%   file we use to generate sample when training, we will set a larger
%   NumMolecular in paras and run generateMolecular for one time before
%   training. Then, during the training, we just need to generate sample
%   and label where molecular is a input.
% We use this file to test the sample generating pipline and process.
% The paras we use in this file is not the final paras we use in training.

%% Main function for the pipline of sample generation

function [label, sample_noised] = sampleGenerator()
    % set parameters
    paras = [];
    paras = setBasicParas(paras);
    paras = generateSampleParas(paras);
    % generate moleculars
    molecular = generateMolecular(paras);       % double
    % generate samples
    sample = generateSample(paras, molecular);  % double normalized
    % further processing samples
    sample_noised = addNoise(paras, sample);    % double normalized
    % generate labels/ground truth
    label = generateLabel(paras);               % double normalized
    
    % print status
    fprintf("molecular (MB): " + ((whos("molecular").bytes)/(1024^2)) + "\n")
    fprintf("sample    (MB): " + ((whos("sample").bytes)/(1024^2)) + "\n")
    fprintf("lable     (MB): " + ((whos("label").bytes)/(1024^2)) + "\n")
    
    % return

    % save
    if exist(mfilename, 'dir'), rmdir(mfilename, 's'); end
    mkdir(mfilename);
    save(fullfile(mfilename, "paras"), "paras")
    saveFrames(mfilename, "molecular", molecular)
    saveFrames(mfilename, "sample", sample)
    saveFrames(mfilename, "sample_noised", sample_noised)
    saveFrames(mfilename, "label", label)
end

%% Set parameters

function paras = setBasicParas(paras)
    % dimensional parameters that need to consider memory
    paras.NumMolecule = 64;             % big affect on running time
    paras.NumFrame    = 1;
    paras.DimFrame    = [128, 128, 64]; % row-column-(depth); yx(z)
    paras.UpSampling  = [8, 8, 8];

    % parameters that adjust distribution of sample parameters
    paras.PixelSize   = [65, 65, 100];  % use to correct the covariance
    paras.MaxStd      = 2;              % adjust covariance of moleculars
    paras.LumRange    = [1/512, 1];
    paras.AppearRange = [1/8, 1/1];     % min, max % of moleculars/frame

    % parameters for adding noise
    paras.noise_mu  = 0;
    paras.noise_var = 1/512;
end

function paras = generateSampleParas(paras)
    % Descriptions:
    % - This function will use basic parameters to randomly generate
    %   sample parameters that used to generate sample.
    % - Basic parameters can help us generate sample with same
    %   distribution but not exatly same. To save a dataset, sample
    %   parameters generated by this function need to be saved so that we
    %   do not need to save the save to save memeory and avoid I/O
    %   performance.
    % Rules:
    % - We load all basic parameters needed at begining and save all the
    %   sample parameters at the end of function. We won't access or modity
    %   the paras during function.
    % - When generting parameters, we use double and do not round the
    %   data. We will do all the dtype change or round the float at the
    %   end of function, when saving parameter.
    % Output:
    %   (D stands for number of dimensions, i.e., length(DimFrame))
    % - mu_set    [D * NumMolecule]           double  non-rounded
    % - cov_set   [D * D * NumMolecule]       double  non-rounded
    % - lum_set   [NumMolecule]               double  non-rounded
    % - mask_set  [NumFrame * NumMolecule]    logical

    % load the basic parameters we will use
    NumMolecule = paras.NumMolecule;
    NumFrame    = paras.NumFrame;
    DimFrame    = paras.DimFrame;
    PixelSize   = paras.PixelSize;
    MaxStd      = paras.MaxStd;
    LumRange    = paras.LumRange;
    AppearRange = paras.AppearRange;

    D = length(DimFrame);  % number of dimensions

    % 1. mu set, [D * NumMolecule]
    mu_set = (DimFrame-1)' .* rand([D, NumMolecule]) + 1;

    % 2. covariance set, [D * D * NumMolecule]
    cov_set = zeros(D, D, NumMolecule);
    % pixel size correction
    MaxStd = MaxStd * (PixelSize(1) ./ PixelSize);
    for n = 1:NumMolecule
        cov_set(:, :, n) = diag((MaxStd.^2) .* rand([1, D]));
    end

    % 3. luminance set, [NumMolecule]
    lum_set = (LumRange(2) - LumRange(1)) * rand([1, NumMolecule]);
    lum_set = lum_set + LumRange(1);

    % 4. mask set, [NumFrame, NumMolecule]
    % determine how many moleculars will appear in each frame
    NumRange = round(NumMolecule * AppearRange);
    num_appear_set = randi(NumRange, [NumFrame, 1]);
    % create a mask stands which moleculars will appear in each frame
    mask_set = zeros(NumFrame, NumMolecule);
    for n = 1:NumFrame
        index = randperm(NumMolecule, num_appear_set(n));
        mask_set(n, index) = 1;  % mask of a molecular is 1 if appear
    end

    % save sample parameters in 'paras,' change dtype/rounded meantime
    paras.mu_set    = mu_set;
    paras.cov_set   = cov_set;
    paras.lum_set   = lum_set;
    paras.mask_set  = logical(mask_set);
end

%% Generate moleculars

function single_molecular = generate_single_molecular(paras, m)
    % load parameters we will use
    DimFrame    = paras.DimFrame;
    mu          = paras.mu_set(:, m);
    cov         = paras.cov_set(:, :, m);
    lum         = paras.lum_set(m);

    D = length(DimFrame);  % number of dimensions

    % take a slice around the mu where the radia is 5 * std
    radius      = ceil(5 * sqrt(diag(cov)));
    lower       = floor(max(mu - radius, ones(D, 1)));
    upper       = ceil(min(mu + radius, DimFrame'));
    diameter    = upper - lower + 1;

    % build coordinate system of the slice
    % We use 'ndgrid' instead of 'meshgrid' to match the coordinate system 
    % of the mu/lower/upper above.
    % For example, if diameter is [11 13 8], meshgrid will return three
    % [13 11 8] matrix but ndgrid return three [11 13 8] matrix.
    % 'meshgrid' use Cartesian coordinate system, i.e. 11 is range of
    % x-axis/column, 13 is range of y-axis/row.
    % 'ndgrid' use matrix coordinate system, i.e. 11 is range of y-axis/row
    % and 13 is range of x-axis/column.
    % Above, for mu/lower/upper, we use matrix coordinate system, thus here
    % we use 'ndgrid'
    index = arrayfun(@(l, u) l:u, lower, upper, 'UniformOutput', false);
    grid_cell = cell(1, D);
    [grid_cell{:}] = ndgrid(index{:});
    coord = cat(D+1, grid_cell{:});                 % [y, x, (z), D]
    coord = reshape(coord, [], D);                  % [yx(z), D]

    % compute the probability density for each point/pixel in slice
    pdf_values = mvnpdf(coord, mu', cov);           % [yx(z), D]

    % set the luminate
    pdf_values = pdf_values * lum / max(pdf_values(:));

    % put the slice back to whole frame to get single molecular frame
    single_molecular = zeros(DimFrame);
    for i = 1:prod(diameter)
        idx = cellfun(@(x) x(i), grid_cell, 'UniformOutput', false);
        single_molecular(idx{:}) = pdf_values(i);
    end
end

function molecular = generateMolecular(paras)
    % load parameters we will use
    NumMolecule = paras.NumMolecule;
    DimFrame    = paras.DimFrame;

    molecular = zeros([NumMolecule, DimFrame]);
    for m = 1:NumMolecule
        single_molecular = generate_single_molecular(paras, m);
        molecular(m, :) = single_molecular(:);
    end
end

%% Generate samples

function sample = generateSample(paras, molecular)
    % load parameters we will use
    NumFrame    = paras.NumFrame;
    DimFrame    = paras.DimFrame;
    mask_set    = paras.mask_set;

    sample = reshape(mask_set * molecular(:, :), [NumFrame, DimFrame]);
end

%% Further processing samples

function sample_noised = addNoise(paras, sample)
    % load parameters we will use
    noise_mu    = paras.noise_mu;
    noise_var   = paras.noise_var;
    
    sample_noised = imnoise(sample, "gaussian", noise_mu, noise_var);
end

%% Generate labels/ground truth

function label = generateLabel(paras)
    % load parameters we will use
    NumMolecule = paras.NumMolecule;
    NumFrame    = paras.NumFrame;
    DimFrame    = paras.DimFrame;
    UpSampling  = paras.UpSampling;
    mu_set      = paras.mu_set;
    lum_set     = paras.lum_set;
    mask_set    = paras.mask_set;

    DimFrame_up = UpSampling .* DimFrame;
    mu_set_up   = UpSampling' .* mu_set;

    label = zeros([NumFrame, DimFrame_up]);
    for f = 1:NumFrame
        for m = 1:NumMolecule
            mu_up = round(mu_set_up(:, m));
            index = arrayfun(@(x) x, mu_up, 'UniformOutput', false);
            label(f, index{:}) = lum_set(m) * mask_set(f, m);
        end
    end
end

%% Help function for save frames into .tif file

function [] = saveTif(path, frame)
    % input frame is normalized float
    frame = uint8(round(frame*255));
    DimFrame = size(frame);
    if length(DimFrame) == 2
        imwrite(frame, path+".tif", ...
            'WriteMode', 'overwrite',  'Compression','none');
    end
    if length(DimFrame) == 3
        imwrite(frame(:, :, 1), path+".tif", ...
            'WriteMode', 'overwrite',  'Compression','none');
        for d = 2:DimFrame(3)
            imwrite(frame(:, :, d), path+".tif", ...
                'WriteMode', 'append',  'Compression','none');
        end
    end
end

function [] = saveFrames(fold, subfold, frames)
    % .tif is for illustration purposes only, the files saved are not
    % dependence of other function
    shape = size(frames);
    NumFrame = shape(1);
    DimFrame = shape(2:end);

    % creat the subfold to store tif
    mkdir(fullfile(fold, subfold));
    for f = 1:NumFrame
        filename = f + "_" + subfold + "_" + fold;
        path = fullfile(fold, subfold, filename);
        saveTif(path, reshape(frames(f, :), DimFrame));
    end
end
